# Lab-2 Report

#### 徐煜森 PB16110173



## 实验整体设计

本次PL0编译器语法分析实验采用LL(1)文法递归下降的方式进行推导，并按要求实现在每次推导时打印出栈的内容和分析树的结构，同时实现了一些情况下的错误处理及错误预测。



## 主要工作

1. 通过明确合理的分工来减少可能出现的merge冲突；规范函数调用操作，使得在merge后易于进行调试。
2. 语法分析中使用LL(1)文法，首先根据语法图写出文法产生式，其中我完成了程序、程序体产生式，并帮助队友更正语句、语句序列和条件的产生式。
3. 实现程序体中变量定义var_declaration函数、子程序定义procedure_declaration函数，条件condition函数，表达式expression函数，项term函数，因子factor函数。其中具体代码可见于[syntax/pl0_tax.c](http://210.45.114.146:880/G_PB16110675/pl0compiler/blob/xuyusen-lab-2/syntax/pl0_tax.c)
4. 代码合并后进行测试，并帮助队友找出bug位置。
5. 使用test_err.pl测试程序错误处理能力，并帮助队友改进程序。



## 遇到问题及解决方案

### 1. 分工

本次实验为小组三个人通过git合作完成一份代码，合作完成代码必然存在分工和将来可能出现的merge冲突问题。

##### 解决方案：

在实验布置后，小组三人进行讨论就分工问题达成统一意见。另外，在我的强烈建议下，明确了写代码规范，如每个人写的函数应该在的位置、函数定义应该在的位置等，尽可能地减少了将来可能发生的merge冲突。之后事实表明，这个建议十分有效。



### 2. 不同人的函数间相互调用可能存在的问题

在实验进行期间，我发现有些产生式的推导需要向后看一个词法单元，又有些产生式的推导无需向后看即可完成。这时意识到，在不同人的函数间相互调用可能存在问题：B不知道A的函数从什么状态(输入词法单元读到什么位置)开始处理，也不知道函数结束后输入读到了什么。

##### 解决方案：

明确在调用函数前读入该函数推导需要的第一个词法单元，在该函数推导结束后，返回前一定读入后一个词法单元，不管是否需要该词法单元判断推导结束。另外，文法栈在函数内进行维护，即在函数内完成推导。



### 3. 变量定义中循环

在写程序体中的变量定义时发现可能存在多个变量一起定义，此时难以判断定义结束和判断语法出错。

##### 解决方案：

与队友讨论后，改进代码结构，将变量定义函数拆分为三个函数var_declaration、var_list、more_var_list分别对应相应的产生式：

1. var_declaration -> var varlist ;
2. varlist -> ident morevarlist

3. morevarlist -> ，varlist  |  epsilon

这样的三个函数就相对容易写出，并且易于判断语法出错。



### 4. 条件中文法存在的左公因子

在完成条件condition函数时，发现队友为condition写的文法不是LL(1)文法，其产生式存在左公因子。

##### 解决方案：

帮助队友将产生式更正。



### 5. 测试中发现问题

##### a. 队友在程序中的产生式写错。

产生式 语句 -> if 条件 then 语句 写成 语句 -> if 条件 then 语句序列 。导致测试test.pl时无法正确推导。

##### b. 队友函数参数写错。

##### c. 队友在错误处理中，遇到遗漏或多余词法单元后，没有更正文法栈的状态，导致测试test_err.pl时只能报出他遇到的第一个错误。



## 总结

这次实验我的部分做得十分开心，因为我的这么长的代码运行第一次就成功，没有出现bug（可能是第一次也是最后一次了），一次成功原因应该是我在合并前又花了比写代码更多的时间来重新看代码。实验中最艰难的部分，在于帮队友找bug。实验过后，练成了看栈状态变化找bug的本事。

总结一下经验，就是在实验中想到问题或有新的想法，一定要及时与队友讨论，否则这个问题可能会在合并的时候变成大问题。另外，重新看自己写的代码是有必要的，可以显著减轻调试负担。